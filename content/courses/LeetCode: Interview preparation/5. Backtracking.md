---
title: "5. Backtracking"
date: "2022-08-09"
type: book
weight: 40
toc: true
# _build:
# render: always
# list: never
---

## A. General Idea

The key _intuition_ to understand backtracking is to imagine and formulize a problem as decision tree.

1. Define the base case for the decision tree; Base case determines the terminal condition of a path in a decision tree.

   - Out of bounds
   - Reach a target sum or value

2. Decide the actions to take in each node of the decision tree.
   - Choose a candidate
   - Prune the candidate
3. Maintain a global state to store the results

## B. Leetcode problems

### 78. Subsets

Given an integer array `nums` of **unique** elements, return _all possible subsets (the power set)._

The solution set **must not** contain duplicate subsets. Return the solution in **any order**.

Example 1:

> **Input:** [1,2,3] \
> **Output:** [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

#### Key Ideas:

{{< spoiler text="code" >}}

```python

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:

        result = []
        subset = []

        def dfs(i):

            if i >= len(nums): # base case - out of bounds
                result.append(subset.copy())
                return

            subset.append(nums[i])
            dfs(i+1)

            subset.pop()
            dfs(i+1)

        dfs(0)

        return result

```

{{< /spoiler >}}

### 46. Permutations

Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.

Example 1:

> **Inputs:** nums = [1,2,3] \
> **Outputs:** [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

#### Key Ideas
