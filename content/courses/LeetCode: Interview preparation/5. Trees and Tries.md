---
title: "5. Trees and Tries"
date: "2022-07-30"
type: book
weight: 5
toc: true
---

{{< toc >}}

## A. General Introduction

### I. Key Methods

1. Identify the base case - _what to do when it reaches the leaf or root node?_
2. Recursive calls to each child node
3. Identify what needs to be calculated with the information from the child nodes
4. Return the calculated result

## B. Leetcode problems

{{< toc >}}

### 226. Invert Binary Tree

Given the `root` of a binary tree, invert the tree, and return its `root`.

{{< figure src="/leetcode/invert1-tree.jpg" width="500px" title="Image from https://leetcode.com/problems/invert-binary-tree/" >}}

##### Key Ideas

- Invert the tree by swapping the left and right children of each node.

{{< spoiler text="Code" >}}

```python

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        if root is None or root.left == None and root.right == None:
            return root

        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)

        return root

```

{{< /spoiler >}}

### 543. Diameter of Binary Tree

Given the `root` of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.

The length of a path between two nodes is represented by the number of edges between them.

#### Key Ideas

- `@BaseCase` The diameter of an empty node is 0.
- `@RecursiveCase` The diameter of a node is the maximum of the diameter of its left and right subtrees.
  - Return the max height of the subtrees plus 1 (_accounts for the edge that connects it to parent node_).

{{< spoiler text="code" >}}

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:

    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:

        result = 0 # global state that is set at each level

        def traverse(root:TreeNode):

            if not root:
                return 0

            rh = traverse(root.right)
            lh = traverse(root.left)

            nonlocal result
            result = max(result, rh+lh)

            return max(lh, rh) + 1

        traverse(root)

        return result

```

{{< /spoiler >}}

### 104. Maximum Depth of Binary Tree

Given the `root` of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Example:

{{< figure src="/leetcode/tmp-tree.jpg" width="300px" title="Image from https://leetcode.com/problems/maximum-depth-of-binary-tree/">}}

> **Input:** root = [3,9,20,null,null,15,7] \
> **Output:** 3

#### Key Ideas

- `@BaseCase` The depth of an empty node is 0.
- `@RecursiveCase` Check the max depth of right and left subtrees.
  - Return the max of the two plus 1 (To include the height of the current node).

{{< spoiler text="code" >}}

```python

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:

        if not root:
            return 0

        depth = 0
        if root.right:
            rd = self.maxDepth(root.right)
            depth = max(depth, rd)

        if root.left:
            ld = self.maxDepth(root.left)
            depth = max(depth, ld)

        return depth + 1

```

{{< /spoiler >}}

### 110. Balanced Binary Tree

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

> a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

Example:

{{< figure src="/leetcode/balance_1.jpg" title="Image from https://leetcode.com/problems/balanced-binary-tree/" >}}

> **Input:** root = [3,9,20,null,null,15,7] \
> **Output:** true

#### Key Ideas

- `@BaseCase` The height of an empty node is zero.
- `@RecursiveCase` The height of a node is the maximum of the height of its left and right subtrees.
  - At every node, calculate if the difference in height between the left and right subtrees is greater than 1.
    - If so, set the balanced set to false.
  - Return the max height of the subtrees plus 1.

{{< spoiler text="code">}}

```python

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:

        balanced = True

        def dfs(root:TreeNode) -> int:

            if root is None:
                return 0

            lh = dfs(root.left)
            rh = dfs(root.right)

            if abs(lh-rh) > 1:
                nonlocal balanced
                balanced = False

            return max(lh, rh) + 1

        dfs(root)

        return balanced

```

{{< /spoiler >}}

### 100. Same Tree

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

Example:

{{< figure src="/leetcode/same-tree.jpg" title="Image from https://leetcode.com/problems/same-tree/" >}}

> **Input:** p = [1,2,3], q = [1,2,3] \
> **Output:** true

#### Key Ideas

- `@BaseCase` If both trees are empty, return true.
- `@RecursiveCase` If the trees are not empty, compare the values of the root nodes.
  - If they are not equal, return false.
  - Otherwise, compare the left and right subtrees.

{{< spoiler text="code" >}}

```python

class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:

        if not p and not q:
            return True

        if p and q and p.val == q.val:

            l = self.isSameTree(p.left, q.left)
            r = self.isSameTree(p.right, q.right)

            if l and r:
                return True

        return False

```

{{< /spoiler >}}

### 572. Subtree of Another Tree

Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.
