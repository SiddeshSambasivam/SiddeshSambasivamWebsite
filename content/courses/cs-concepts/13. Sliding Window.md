---
title: "13. Sliding Window"
date: "2022-08-24"
type: book
weight: 13
---

## A. General Introduction

#### I. What is it?

A powerful algorithmic mental model.

- Usually involves **iterable/sequential** data structures.
  - **contiguous** sequence of elements
  - strings, arrays, linked lists, etc.
- _Goal:_ Min, Max, Longest, Shortest, Contained
  - Calculating somthing: Average, sum, etc.

#### II. Lets meet the variants

{{< figure src="/leetcode/variants.jpg" width="600px" title="Some variants of the 'problem'">}}

1. Fixed length variant

   - max sum of subarray of size k

2. Dynamic variant

   - smallest sum that is greater than or equal to a target

3. Dynamic variant w/ Auxillary data structure (hashmap, set, etc.)
   - longest substring with at most k distinct characters
   - string permutation

_Commonalities:_

- Everything is grouped in a sequence

## B. Leetcode problems

### 121. Best Time to Buy and Sell Stock

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.

Example:

> **Input:** prices = [7,1,5,3,6,4] \
> **Output:** 5 \
> **Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. \
> Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

#### Key ideas:

- The auxillary data structure is a `min_price` variable
  - We keep track of the minimum price we have seen so far
  - We can use this to calculate the maximum profit we can make

{{< spoiler text="code" >}}

```python

class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        profit = 0
        minBuy = prices[0]

        for sellP in prices:
            profit = max(profit, sellP-minBuy)
            minBuy = min(minBuy, sellP)

        return profit

```

{{< /spoiler >}}

### 3. Longest Substring Without Repeating Characters

Given a string `s`, find the length of the longest substring without repeating characters.

Example:

> **Input:** s = "abcabcbb"
> **Output:** 3
> **Explanation:** The answer is "abc", with the length of 3.

#### Key ideas:

- Move the forward pointer of the window with the outer `for` loop
  - Maintain a `set` of the characters in the window
  - At any point, keep removing the character at the beginning of the window until the window is valid
    - Increment the window size by 1 for each removal
- Keep track of the maximum length of the substring

{{< spoiler text="code" >}}

```python

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        if len(s) == 0:
            return 0

        start = 0
        seen = set()
        maxlen = 1

        for i in range(len(s)):

            while s[i] in seen:
                seen.remove(s[start])
                start += 1

            seen.add(s[i])
            maxlen = max(maxlen, len(seen))

        return maxlen

```

{{< /spoiler >}}

### 567. Permutation in String

Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`, or `false` otherwise.

In other words, return `true` if one of `s1`'s permutations is the substring of `s2`.

Example:

> **Input:** s1="ab" s2="eidbaooo" \
> **Output:** true
> **Explanation:** s2 contains one permutation of s1 ("ba").

#### Key ideas:

- Checking permutation of one string in another is essentially checking the anagram in the window
  - run a loop while the right pointer is less than the length of `s2`
    - Use a hashmap to keep track of the characters in the window
    * If it is equal to the hashmap of `s1`, return `true`
    * Increment both right and left pointers by 1

{{< spoiler text="code" >}}

```python

from collections import Counter

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:

        if len(s1) > len(s2):
            return False

        l = 0
        r = len(s1)
        s1Count = Counter(s1)

        while r <= len(s2):
            if s1Count == Counter(s2[l:r]):
                return True
            l += 1
            r += 1

        return False

```

{{< /spoiler >}}

### 76. Minimum Window Substring

Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

A **substring** is a contiguous sequence of characters within the string.

Example:

> **Input:** s = "ADOBECODEBANC", t = "ABC" \
> **Output:** "BANC"
> **Explanation:** The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.

#### Key ideas:

{{< spoiler text="code" >}}

```python

```

{{< /spoiler >}}
